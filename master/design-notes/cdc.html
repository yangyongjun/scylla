


<!doctype html>
<html class="no-js" lang="en">
  
<head><!-- begin head.html -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>
    CDC | Scylla Docs
    </title>
    <meta name="description" content="Scylla is an Apache Cassandra-compatible NoSQL data store that can handle 1 million transactions per second on a single server."/>

    <link rel="icon" href="../_static/img/favicon.ico" type="image/x-icon"/>
    <link rel="canonical" href="https://docs.scylladb.com/">

    <link rel="author" href="mailto:info@scylladb.com">
    <link rel="stylesheet" href="../_static/" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx_tabs/semantic-ui-2.4.1/segment.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx_tabs/semantic-ui-2.4.1/menu.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx_tabs/semantic-ui-2.4.1/tab.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx_tabs/tabs.css" />
    
    <link href='https://fonts.googleapis.com/css?family=Roboto:400,100,300,500,700' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/foundation/5.5.2/css/foundation.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/css/doc/main.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>

    <script src="../_static/js/vendor/modernizr.js"></script>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-T8P2JP');</script>
    <!-- End Google Tag Manager -->

    <!-- Marketo -->
    <script type="text/javascript"> (function() { var didInit = false; function initMunchkin() { if(didInit === false) { didInit = true; Munchkin.init('791-QBF-350'); } } var s = document.createElement('script'); s.type = 'text/javascript'; s.async = true; s.src = '//munchkin.marketo.net/munchkin.js'; s.onreadystatechange = function() { if (this.readyState == 'complete' || this.readyState == 'loaded') { initMunchkin(); } }; s.onload = initMunchkin; document.getElementsByTagName('head')[0].appendChild(s); })(); </script>
    <!-- End Marketo -->

<!-- end head.html -->
</head>

<body>



<header id="header" class="animated">
    <div class="topbar_continer contain-to-grid clearfix">
        <nav class="top-bar" id="top-bar" data-topbar role="navigation">
            <ul class="title-area">
                <li class="name">
                    <div class="logo">
                        <a href="https://docs.scylladb.com/"><img src="../_static/img/logo-scylla-docs.svg" alt="" width="151"></a>
                    </div>
                </li>
                <li class="toggle-topbar"><a href="#"><span class="icon-manu"></span></a></li>
            </ul>
            <section class="top-bar-section clearfix">
                <ul class="right">
                    
                    <li>
                        <a href="https://scylla.docs.scylladb.com">Scylla Developer Notes</a>
                    </li>
                    
                    <li>
                        <a href="https://university.scylladb.com/">Scylla University</a>
                    </li>
                    
                    <li>
                        <a href="https://www.scylladb.com/">ScyllaDB Home</a>
                    </li>
                    
                    <li class="search_continer show-for-medium-up">	
                        <ci-search></ci-search>	
                    </li>	
                </ul>
            </section>
        </nav>
    </div>
</header>
<section id="content">
    <div class="row">
	
	<div class="large-6 large-push-3 columns">

        

        <section id="cdc">
<h1>CDC<a class="headerlink" href="#cdc" title="Permalink to this headline">¶</a></h1>
<section id="stream-ids">
<h2>Stream IDs<a class="headerlink" href="#stream-ids" title="Permalink to this headline">¶</a></h2>
<p>A <strong>stream ID</strong> is a 128-bit number, represented as a pair of <code class="docutils literal notranslate"><span class="pre">int64</span></code>s:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">stream_id</span> <span class="n">final</span> <span class="p">{</span>
    <span class="n">int64_t</span> <span class="n">_first</span><span class="p">;</span>
    <span class="n">int64_t</span> <span class="n">_second</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
    <span class="o">...</span> <span class="n">methods</span> <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>When a write is performed to a CDC-enabled user-created table (the “base table”), a corresponding write, or a set of writes, is synchronously performed to the CDC table associated with the base table (the “log table”); the partition key for these log writes is chosen from some set of stream IDs. Where this set comes from and how those stream IDs are chosen is described below.</p>
<p>The 128 bits are composed of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">128</span>           <span class="mi">64</span>            <span class="mi">27</span>            <span class="mi">4</span>             <span class="mi">0</span>
  <span class="o">|</span> <span class="o">&lt;</span><span class="n">token</span><span class="p">:</span><span class="mi">64</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">random</span><span class="p">:</span><span class="mi">38</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">index</span><span class="p">:</span><span class="mi">22</span><span class="o">&gt;</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">version</span><span class="p">:</span><span class="mi">4</span><span class="o">&gt;</span> <span class="o">|</span>
</pre></div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">version</span></code> making up the lowest 4 bits. The id is stored as bytes, and sorted on string ordering, i.e. the high qword (token) is msb in ordering.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">index</span></code> bits indicate the vnode index the id belongs to, i.e. the vnode owning the end of the token range in which the id sits.</p>
<p>The random bits exist to help ensure ids are sufficiently unique across
generations.</p>
</section>
<section id="generations">
<h2>Generations<a class="headerlink" href="#generations" title="Permalink to this headline">¶</a></h2>
<p>A <strong>CDC generation</strong> is a structure consisting of:</p>
<ol class="simple">
<li><p>a <strong>generation timestamp</strong>, describing the time point from which this generation “starts operating” (more on that later),</p></li>
<li><p>a set of stream IDs,</p></li>
<li><p>a mapping from the set of tokens (in the entire token ring) to the set of stream IDs in this generation.</p></li>
</ol>
<p>The mapping from point 3 has a simple structure, allowing us to compactly store a CDC generation. This is the purpose of the <code class="docutils literal notranslate"><span class="pre">cdc::topology_description</span></code> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">namespace</span> <span class="n">cdc</span> <span class="p">{</span>
    <span class="n">struct</span> <span class="n">token_range_description</span> <span class="p">{</span>
        <span class="n">dht</span><span class="p">::</span><span class="n">token</span> <span class="n">token_range_end</span><span class="p">;</span>
        <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">stream_id</span><span class="o">&gt;</span> <span class="n">streams</span><span class="p">;</span>
        <span class="n">uint8_t</span> <span class="n">sharding_ignore_msb</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">class</span> <span class="nc">topology_description</span> <span class="p">{</span>
        <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">token_range_description</span><span class="o">&gt;</span> <span class="n">_entries</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
        <span class="o">...</span> <span class="n">methods</span> <span class="o">...</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>From a <code class="docutils literal notranslate"><span class="pre">cdc::topology_description</span></code> we can read the set of stream IDs of this generation and the mapping. How <code class="docutils literal notranslate"><span class="pre">cdc::topology_description</span></code> represents the mapping is explained later.</p>
<p>Each node in a Scylla cluster stores a set of CDC generations using the <code class="docutils literal notranslate"><span class="pre">cdc::metadata</span></code> class. Simplified definition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">namespace</span> <span class="n">cdc</span> <span class="p">{</span>
    <span class="k">class</span> <span class="nc">metadata</span> <span class="n">final</span> <span class="p">{</span>
        <span class="n">using</span> <span class="n">container_t</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">map</span><span class="o">&lt;</span><span class="n">api</span><span class="p">::</span><span class="n">timestamp_type</span><span class="p">,</span> <span class="n">topology_description</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="n">container_t</span> <span class="n">_gens</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">_gens</span></code> map’s key is the generation’s timestamp.</p>
<p>Let <code class="docutils literal notranslate"><span class="pre">container_t::iterator</span> <span class="pre">it</span></code> point to some generation in this set. We say that the generation given by <code class="docutils literal notranslate"><span class="pre">*it</span></code> <strong>operates</strong> in a time interval <code class="docutils literal notranslate"><span class="pre">[T,</span> <span class="pre">T')</span></code> (where T, T’ are timestamps) if and only if:</p>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T</span></code> is the generation’s timestamp (<code class="docutils literal notranslate"><span class="pre">it-&gt;first</span></code>),</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">T'</span></code> is the following generation’s timestamp (<code class="docutils literal notranslate"><span class="pre">std::next(it)-&gt;first</span></code>).</p></li>
</ol>
<p>This set changes while the node runs. If there is no following generation (<code class="docutils literal notranslate"><span class="pre">std::next(it)</span> <span class="pre">==</span> <span class="pre">std::end(_gens)</span></code>), it simply means that this node doesn’t yet know what that following generation will be. It might happen that <code class="docutils literal notranslate"><span class="pre">T'</span> <span class="pre">=</span> <span class="pre">∞</span></code> (i.e. there really won’t ever be a following generation) but that’s unlikely.</p>
<p>When a write is performed to a base table, the write is translated to a mutation, which holds a timestamp. This timestamp together with the token of the write’s partition key is used to retrieve the stream ID which will then be used to create a corresponding log table write. The stream ID is taken from the generation operating at this timestamp using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">cdc</span><span class="p">::</span><span class="n">stream_id</span> <span class="n">cdc</span><span class="p">::</span><span class="n">metadata</span><span class="p">::</span><span class="n">get_stream</span><span class="p">(</span><span class="n">api</span><span class="p">::</span><span class="n">timestamp_type</span> <span class="n">ts</span><span class="p">,</span> <span class="n">dht</span><span class="p">::</span><span class="n">token</span> <span class="n">tok</span><span class="p">,</span> <span class="n">const</span> <span class="n">dht</span><span class="p">::</span><span class="n">i_partitioner</span><span class="o">&amp;</span><span class="p">);</span>
</pre></div>
</div>
<p>Here’s a simplified snippet of code illustrating how the log write’s mutation is created (from cdc/log.cc; <code class="docutils literal notranslate"><span class="pre">m</span></code> is the base table mutation):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">mutation</span> <span class="n">transform</span><span class="p">(</span><span class="n">const</span> <span class="n">mutation</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="n">const</span> <span class="p">{</span>
        <span class="n">auto</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">find_timestamp</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
        <span class="n">auto</span> <span class="n">stream_id</span> <span class="o">=</span> <span class="n">_ctx</span><span class="o">.</span><span class="n">_cdc_metadata</span><span class="o">.</span><span class="n">get_stream</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">token</span><span class="p">(),</span> <span class="n">_ctx</span><span class="o">.</span><span class="n">_partitioner</span><span class="p">);</span>
        <span class="n">mutation</span> <span class="n">res</span><span class="p">(</span><span class="n">_log_schema</span><span class="p">,</span> <span class="n">stream_id</span><span class="o">.</span><span class="n">to_partition_key</span><span class="p">(</span><span class="o">*</span><span class="n">_log_schema</span><span class="p">));</span>

        <span class="o">...</span> <span class="n">fill</span> <span class="s2">&quot;res&quot;</span> <span class="k">with</span> <span class="n">the</span> <span class="n">log</span> <span class="n">write</span><span class="s1">&#39;s column data ...</span>

    <span class="p">}</span>
</pre></div>
</div>
<section id="the-generation-s-mapping">
<h3>The generation’s mapping<a class="headerlink" href="#the-generation-s-mapping" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">cdc::topology_description</span></code> class contains a vector of <code class="docutils literal notranslate"><span class="pre">token_range_description</span></code> entries, sorted by <code class="docutils literal notranslate"><span class="pre">token_range_end</span></code>. These entries split the token ring into ranges: for each <code class="docutils literal notranslate"><span class="pre">i</span></code> in <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">...,</span> <span class="pre">_entries.size()</span> <span class="pre">-</span> <span class="pre">1</span></code> we get the range (<code class="docutils literal notranslate"><span class="pre">_entries[i].token_range_end</span></code>, <code class="docutils literal notranslate"><span class="pre">_entries[(i+1)</span> <span class="pre">%</span> <span class="pre">_entries.size()]</span></code>] (the range is left-opened, right-closed).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">i</span></code>th entry defines how tokens in the <code class="docutils literal notranslate"><span class="pre">i</span></code>th range (the one ending with <code class="docutils literal notranslate"><span class="pre">_entries[i].token_range_end</span></code>) are mapped to the vector of streams given by <code class="docutils literal notranslate"><span class="pre">_entries[i].streams</span></code> as follows. Suppose that the used partitioner is given by <code class="docutils literal notranslate"><span class="pre">p</span></code> (of type <code class="docutils literal notranslate"><span class="pre">i_partitioner&amp;</span></code>). Suppose <code class="docutils literal notranslate"><span class="pre">tok</span></code> (of type <code class="docutils literal notranslate"><span class="pre">dht::token</span></code>) falls into the <code class="docutils literal notranslate"><span class="pre">i</span></code>th range.
Then <code class="docutils literal notranslate"><span class="pre">tok</span></code> is mapped into</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_entries</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">p</span><span class="o">.</span><span class="n">shard_of</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">_entries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">streams</span><span class="o">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">_entries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sharding_ignore_msb</span><span class="p">)]</span>
</pre></div>
</div>
<p>The motivation for this is the following: the token ranges defined by <code class="docutils literal notranslate"><span class="pre">topology_description</span></code> using <code class="docutils literal notranslate"><span class="pre">token_range_end</span></code>s are a refinement of vnodes in the token ring at the time when this generation operates (i.e. each range defined by this generation is wholly contained in a single vnode). The streams in vector <code class="docutils literal notranslate"><span class="pre">_entries[i].streams</span></code> have their tokens in the <code class="docutils literal notranslate"><span class="pre">i</span></code>th range. Therefore we map each token <code class="docutils literal notranslate"><span class="pre">tok</span></code> to a stream whose token falls into the the same vnode as <code class="docutils literal notranslate"><span class="pre">tok</span></code>. Hence, when we perform a base table write, the corresponding CDC log write will fall into the same vnode, thus it will have the same set of replicas as the base write. We call this property <strong>colocation</strong> of base and log writes.</p>
<p>To achieve the above it would be enough if <code class="docutils literal notranslate"><span class="pre">_entries[i].streams</span></code> was a single stream, not a vector of streams. But we went further and aim to achieve not only colocation of replicas, but also colocation of shards (not necessarily at all replicas, but a subset of them at least).</p>
<p>Suppose that some node <code class="docutils literal notranslate"><span class="pre">A</span></code> is a replica for the vnode containing the <code class="docutils literal notranslate"><span class="pre">i</span></code>th range. Suppose that the number of shards of <code class="docutils literal notranslate"><span class="pre">A</span></code> is <code class="docutils literal notranslate"><span class="pre">_entries[i].streams.size()</span></code>, and the value of <code class="docutils literal notranslate"><span class="pre">sharding_ignore_msb</span></code> parameter used by the configured partitioner is <code class="docutils literal notranslate"><span class="pre">_entries[i].sharding_ignore_msb</span></code>. Suppose that we chose <code class="docutils literal notranslate"><span class="pre">_entries[i].streams[j]</span></code> so that its token is owned by the <code class="docutils literal notranslate"><span class="pre">j</span></code>th shard on node <code class="docutils literal notranslate"><span class="pre">A</span></code>.
Then base table writes with tokens that fall into the <code class="docutils literal notranslate"><span class="pre">i</span></code>th range and into the <code class="docutils literal notranslate"><span class="pre">j</span></code>th shard on node <code class="docutils literal notranslate"><span class="pre">A</span></code> will have their corresponding log table entries also written to the <code class="docutils literal notranslate"><span class="pre">j</span></code>th shard, at least on node <code class="docutils literal notranslate"><span class="pre">A</span></code>. If all nodes use the same number of shards (which is pretty common), we’ll get shard-colocation on every replica.</p>
<p>Vnode-colocation is important for consistency: when the base write goes to the same set of replicas as the log write, it is possible to make sure that each replica either receives both writes or none of them. Thus the CDC log will be able to truly reflect what happened in the base table.
Shard-colocation is an optimization.</p>
</section>
</section>
<section id="generation-switching">
<h2>Generation switching<a class="headerlink" href="#generation-switching" title="Permalink to this headline">¶</a></h2>
<p>Having different generations operating at different points in time is necessary to maintain colocation in presence of topology changes. When a new node joins the cluster it modifies the token ring by refining existing vnodes into smaller vnodes. But before it does it, it will introduce a new CDC generation whose token ranges refine those new (smaller) vnodes (which means they also refine the old vnodes; that way writes will be colocated on both old and new replicas).</p>
<p>The joining node learns about the current vnodes, chooses tokens which will split them into smaller vnodes and creates a new <code class="docutils literal notranslate"><span class="pre">cdc::topology_description</span></code> which refines those smaller vnodes. This is done in the <code class="docutils literal notranslate"><span class="pre">cdc::generate_topology_description</span></code> function. It then inserts the generation description into an internal distributed table <code class="docutils literal notranslate"><span class="pre">cdc_generation_descriptions</span></code> in the <code class="docutils literal notranslate"><span class="pre">system_distributed</span></code> keyspace. The table is defined as follows (from db/system_distributed_keyspace.cc):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        return schema_builder(system_distributed_keyspace::NAME, system_distributed_keyspace::CDC_TOPOLOGY_DESCRIPTION, {id})
                /* The timestamp of this CDC generation. */
                .with_column(&quot;time&quot;, timestamp_type, column_kind::partition_key)
                /* The description of this CDC generation (see `cdc::topology_description`). */
                .with_column(&quot;description&quot;, cdc_generation_description_type)
                /* Expiration time of this CDC generation (or null if not expired). */
                .with_column(&quot;expired&quot;, timestamp_type)
                .with_version(system_keyspace::generate_schema_version(id))
                .build();
</pre></div>
</div>
<p>where</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">thread_local</span> <span class="n">data_type</span> <span class="n">cdc_stream_tuple_type</span> <span class="o">=</span> <span class="n">tuple_type_impl</span><span class="p">::</span><span class="n">get_instance</span><span class="p">({</span><span class="n">long_type</span><span class="p">,</span> <span class="n">long_type</span><span class="p">});</span>
<span class="n">thread_local</span> <span class="n">data_type</span> <span class="n">cdc_streams_list_type</span> <span class="o">=</span> <span class="n">list_type_impl</span><span class="p">::</span><span class="n">get_instance</span><span class="p">(</span><span class="n">cdc_stream_tuple_type</span><span class="p">,</span> <span class="n">false</span><span class="p">);</span>
<span class="n">thread_local</span> <span class="n">data_type</span> <span class="n">cdc_token_range_description_type</span> <span class="o">=</span> <span class="n">tuple_type_impl</span><span class="p">::</span><span class="n">get_instance</span><span class="p">(</span>
        <span class="p">{</span> <span class="n">utf8_type</span>             <span class="o">//</span> <span class="n">dht</span><span class="p">::</span><span class="n">token</span> <span class="n">token_range_end</span><span class="p">;</span>
        <span class="p">,</span> <span class="n">cdc_streams_list_type</span> <span class="o">//</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">stream_id</span><span class="o">&gt;</span> <span class="n">streams</span><span class="p">;</span>
        <span class="p">,</span> <span class="n">byte_type</span>             <span class="o">//</span> <span class="n">uint8_t</span> <span class="n">sharding_ignore_msb</span><span class="p">;</span>
        <span class="p">});</span>
<span class="n">thread_local</span> <span class="n">data_type</span> <span class="n">cdc_generation_description_type</span> <span class="o">=</span> <span class="n">list_type_impl</span><span class="p">::</span><span class="n">get_instance</span><span class="p">(</span><span class="n">cdc_token_range_description_type</span><span class="p">,</span> <span class="n">false</span><span class="p">);</span>
</pre></div>
</div>
<p>The timestamp for the new generation is chosen by taking the node’s local time and adding a minute or two so that other nodes have a chance to learn about this generation before it starts operating. Thus, the node makes the following assumptions:</p>
<ol class="simple">
<li><p>its clock is not too desynchronized with other nodes’ clocks,</p></li>
<li><p>the cluster is not partitioned.</p></li>
</ol>
<p>Future patches will make the solution safe by using a two-phase-commit approach.</p>
<p>Next, the node starts gossiping the timestamp of the new generation together with its set of chosen tokens and status:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        <span class="n">_gossiper</span><span class="o">.</span><span class="n">add_local_application_state</span><span class="p">({</span>
            <span class="p">{</span> <span class="n">gms</span><span class="p">::</span><span class="n">application_state</span><span class="p">::</span><span class="n">TOKENS</span><span class="p">,</span> <span class="n">versioned_value</span><span class="p">::</span><span class="n">tokens</span><span class="p">(</span><span class="n">_bootstrap_tokens</span><span class="p">)</span> <span class="p">},</span>
            <span class="p">{</span> <span class="n">gms</span><span class="p">::</span><span class="n">application_state</span><span class="p">::</span><span class="n">CDC_GENERATION_ID</span><span class="p">,</span> <span class="n">versioned_value</span><span class="p">::</span><span class="n">cdc_generation_id</span><span class="p">(</span><span class="n">_cdc_gen_id</span><span class="p">)</span> <span class="p">},</span>
            <span class="p">{</span> <span class="n">gms</span><span class="p">::</span><span class="n">application_state</span><span class="p">::</span><span class="n">STATUS</span><span class="p">,</span> <span class="n">versioned_value</span><span class="p">::</span><span class="n">bootstrapping</span><span class="p">(</span><span class="n">_bootstrap_tokens</span><span class="p">)</span> <span class="p">},</span>
        <span class="p">})</span><span class="o">.</span><span class="n">get</span><span class="p">();</span>
</pre></div>
</div>
<p>The node persists the currently gossiped timestamp in order to recover it on restart in the <code class="docutils literal notranslate"><span class="pre">system.cdc_local</span></code> table. This is the schema:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CREATE</span> <span class="n">TABLE</span> <span class="n">system</span><span class="o">.</span><span class="n">cdc_local</span> <span class="p">(</span>
    <span class="n">key</span> <span class="n">text</span> <span class="n">PRIMARY</span> <span class="n">KEY</span><span class="p">,</span>
    <span class="n">streams_timestamp</span> <span class="n">timestamp</span>
<span class="p">)</span> <span class="o">...</span>
</pre></div>
</div>
<p>The timestamp is kept under the <code class="docutils literal notranslate"><span class="pre">&quot;cdc_local&quot;</span></code> key in the <code class="docutils literal notranslate"><span class="pre">streams_timestamp</span></code> column.</p>
<p>When other nodes learn about the generation, they’ll extract it from the <code class="docutils literal notranslate"><span class="pre">cdc_generation_descriptions</span></code> table and save it using <code class="docutils literal notranslate"><span class="pre">cdc::metadata::insert(db_clock::time_point,</span> <span class="pre">topology_description&amp;&amp;)</span></code>.
Notice that nodes learn about the generation together with the new node’s tokens. When they learn about its tokens they’ll immediately start sending writes to the new node (in the case of bootstrapping, it will become a pending replica). But the old generation will still be operating for a minute or two. Thus colocation will be lost for a while. This problem will be fixed when the two-phase-commit approach is implemented.</p>
<p>We’re not able to prevent a node learning about a new generation too late due to a network partition: if gossip doesn’t reach the node in time, some writes might be sent to the wrong (old) generation.
However, it could happen that a node learns about the generation from gossip in time, but then won’t be able to extract it from <code class="docutils literal notranslate"><span class="pre">cdc_generation_descriptions</span></code>. In that case we can still maintain consistency: the node will remember that there is a new generation even though it doesn’t yet know what it is (just the timestamp) using the <code class="docutils literal notranslate"><span class="pre">cdc::metadata::prepare(db_clock::time_point)</span></code> method, and then <em>reject</em> writes for CDC-enabled tables that are supposed to use this new generation. The node will keep trying to read the generation’s data in background until it succeeds or sees that it’s not necessary anymore (e.g. because the generation was already superseded by a new generation).
Thus we give up availability for safety. This likely won’t happen if the administrator ensures that the cluster is not partitioned before bootstrapping a new node. This problem will also be mitigated with a future patch.</p>
<p>Due to the need of maintaining colocation we don’t allow the client to send writes with arbitrary timestamps.
Suppose that a write is requested and the write coordinator’s local clock has time <code class="docutils literal notranslate"><span class="pre">C</span></code> and the generation operating at time <code class="docutils literal notranslate"><span class="pre">C</span></code> has timestamp <code class="docutils literal notranslate"><span class="pre">T</span></code> (<code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">&lt;=</span> <span class="pre">C</span></code>). Then we only allow the write if its timestamp is in the interval [<code class="docutils literal notranslate"><span class="pre">T</span></code>, <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">+</span> <span class="pre">generation_leeway</span></code>), where <code class="docutils literal notranslate"><span class="pre">generation_leeway</span></code> is a small time-inteval constant (e.g. 5 seconds).
Reason: we cannot allow writes before <code class="docutils literal notranslate"><span class="pre">T</span></code>, because they belong to the old generation whose token ranges might no longer refine the current vnodes, so the corresponding log write would not necessarily be colocated with the base write. We also cannot allow writes too far “into the future” because we don’t know what generation will be operating at that time (the node which will introduce this generation might not have joined yet). But, as mentioned before, we assume that we’ll learn about the next generation in time. Again — the need for this assumption will be gone in a future patch.</p>
</section>
<section id="streams-description-tables">
<h2>Streams description tables<a class="headerlink" href="#streams-description-tables" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">cdc_streams_descriptions_v2</span></code> table in the <code class="docutils literal notranslate"><span class="pre">system_distributed</span></code> keyspace allows CDC clients to learn about available sets of streams and the time intervals they are operating at. It’s definition is as follows (db/system_distributed_keyspace.cc):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        return schema_builder(system_distributed_keyspace::NAME, system_distributed_keyspace::CDC_DESC_V2, {id})
                /* The timestamp of this CDC generation. */
                .with_column(&quot;time&quot;, timestamp_type, column_kind::partition_key)
                /* For convenience, the list of stream IDs in this generation is split into token ranges
                 * which the stream IDs were mapped to (by the partitioner) when the generation was created.  */
                .with_column(&quot;range_end&quot;, long_type, column_kind::clustering_key)
                /* The set of stream identifiers used in this CDC generation for the token range
                 * ending on `range_end`. */
                .with_column(&quot;streams&quot;, cdc_streams_set_type)
                .with_version(system_keyspace::generate_schema_version(id))
                .build();
</pre></div>
</div>
<p>where</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">thread_local</span> <span class="n">data_type</span> <span class="n">cdc_stream_tuple_type</span> <span class="o">=</span> <span class="n">tuple_type_impl</span><span class="p">::</span><span class="n">get_instance</span><span class="p">({</span><span class="n">long_type</span><span class="p">,</span> <span class="n">long_type</span><span class="p">});</span>
<span class="n">thread_local</span> <span class="n">data_type</span> <span class="n">cdc_streams_set_type</span> <span class="o">=</span> <span class="n">set_type_impl</span><span class="p">::</span><span class="n">get_instance</span><span class="p">(</span><span class="n">cdc_stream_tuple_type</span><span class="p">,</span> <span class="n">false</span><span class="p">);</span>
</pre></div>
</div>
<p>This table contains each generation’s timestamp (as partition key) and the set of stream IDs used by this generation grouped by token ranges that the stream IDs are mapped to. It is meant to be user-facing, in contrast to <code class="docutils literal notranslate"><span class="pre">cdc_generation_descriptions</span></code> which is used internally.</p>
<p>There is a second table that contains just the generations’ timestamps, <code class="docutils literal notranslate"><span class="pre">cdc_generation_timestamps</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        <span class="k">return</span> <span class="n">schema_builder</span><span class="p">(</span><span class="n">system_distributed_keyspace</span><span class="p">::</span><span class="n">NAME</span><span class="p">,</span> <span class="n">system_distributed_keyspace</span><span class="p">::</span><span class="n">CDC_TIMESTAMPS</span><span class="p">,</span> <span class="p">{</span><span class="nb">id</span><span class="p">})</span>
                <span class="o">/*</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">single</span><span class="o">-</span><span class="n">partition</span> <span class="n">table</span><span class="o">.</span> <span class="n">The</span> <span class="n">partition</span> <span class="n">key</span> <span class="ow">is</span> <span class="n">always</span> <span class="s2">&quot;timestamps&quot;</span><span class="o">.</span> <span class="o">*/</span>
                <span class="o">.</span><span class="n">with_column</span><span class="p">(</span><span class="s2">&quot;key&quot;</span><span class="p">,</span> <span class="n">utf8_type</span><span class="p">,</span> <span class="n">column_kind</span><span class="p">::</span><span class="n">partition_key</span><span class="p">)</span>
                <span class="o">/*</span> <span class="n">The</span> <span class="n">timestamp</span> <span class="n">of</span> <span class="n">this</span> <span class="n">CDC</span> <span class="n">generation</span><span class="o">.</span> <span class="o">*/</span>
                <span class="o">.</span><span class="n">with_column</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">timestamp_type</span><span class="p">,</span> <span class="n">column_kind</span><span class="p">::</span><span class="n">clustering_key</span><span class="p">)</span>
                <span class="o">/*</span> <span class="n">Expiration</span> <span class="n">time</span> <span class="n">of</span> <span class="n">this</span> <span class="n">CDC</span> <span class="n">generation</span> <span class="p">(</span><span class="ow">or</span> <span class="n">null</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">expired</span><span class="p">)</span><span class="o">.</span> <span class="o">*/</span>
                <span class="o">.</span><span class="n">with_column</span><span class="p">(</span><span class="s2">&quot;expired&quot;</span><span class="p">,</span> <span class="n">timestamp_type</span><span class="p">)</span>
                <span class="o">.</span><span class="n">with_version</span><span class="p">(</span><span class="n">system_keyspace</span><span class="p">::</span><span class="n">generate_schema_version</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span>
                <span class="o">.</span><span class="n">build</span><span class="p">();</span>
</pre></div>
</div>
<p>It is a single-partition table, containing the timestamps of generations found in <code class="docutils literal notranslate"><span class="pre">cdc_streams_descriptions_v2</span></code> in separate clustered rows. It allows clients to efficiently query if there are any new generations, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SELECT time FROM system_distributed.cdc_generation_timestamps` WHERE time &gt; X
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">X</span></code> is the last timestamp known by that particular client.</p>
<p>When nodes learn about a CDC generation through gossip, they race to update these description tables by first inserting the set of rows containing this generation’s stream IDs into <code class="docutils literal notranslate"><span class="pre">cdc_streams_descriptions_v2</span></code> and then, if the node succeeds, by inserting its timestamp into <code class="docutils literal notranslate"><span class="pre">cdc_generation_timestamps</span></code> (see <code class="docutils literal notranslate"><span class="pre">cdc::update_streams_description</span></code>). This operation is idempotent so it doesn’t matter if multiple nodes do it at the same time.</p>
<p>Note that the first phase of inserting stream IDs may fail in the middle; in that case, the partition for that generation may contain partial information. Thus a client can only safely read a partition from <code class="docutils literal notranslate"><span class="pre">cdc_streams_descriptions_v2</span></code> (i.e. without the risk of observing only a part of the stream IDs) if they first observe its timestamp in <code class="docutils literal notranslate"><span class="pre">cdc_generation_timestamps</span></code>.</p>
</section>
<section id="streams-description-table-v1-and-rewriting">
<h2>Streams description table V1 and rewriting<a class="headerlink" href="#streams-description-table-v1-and-rewriting" title="Permalink to this headline">¶</a></h2>
<p>As the name suggests, <code class="docutils literal notranslate"><span class="pre">cdc_streams_descriptions_v2</span></code> is the second version of the streams description table. The previous schema was:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        <span class="k">return</span> <span class="n">schema_builder</span><span class="p">(</span><span class="n">system_distributed_keyspace</span><span class="p">::</span><span class="n">NAME</span><span class="p">,</span> <span class="n">system_distributed_keyspace</span><span class="p">::</span><span class="n">CDC_DESC</span><span class="p">,</span> <span class="p">{</span><span class="nb">id</span><span class="p">})</span>
                <span class="o">/*</span> <span class="n">The</span> <span class="n">timestamp</span> <span class="n">of</span> <span class="n">this</span> <span class="n">CDC</span> <span class="n">generation</span><span class="o">.</span> <span class="o">*/</span>
                <span class="o">.</span><span class="n">with_column</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">timestamp_type</span><span class="p">,</span> <span class="n">column_kind</span><span class="p">::</span><span class="n">partition_key</span><span class="p">)</span>
                <span class="o">/*</span> <span class="n">The</span> <span class="nb">set</span> <span class="n">of</span> <span class="n">stream</span> <span class="n">identifiers</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">CDC</span> <span class="n">generation</span><span class="o">.</span> <span class="o">*/</span>
                <span class="o">.</span><span class="n">with_column</span><span class="p">(</span><span class="s2">&quot;streams&quot;</span><span class="p">,</span> <span class="n">cdc_streams_set_type</span><span class="p">)</span>
                <span class="o">/*</span> <span class="n">Expiration</span> <span class="n">time</span> <span class="n">of</span> <span class="n">this</span> <span class="n">CDC</span> <span class="n">generation</span> <span class="p">(</span><span class="ow">or</span> <span class="n">null</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">expired</span><span class="p">)</span><span class="o">.</span> <span class="o">*/</span>
                <span class="o">.</span><span class="n">with_column</span><span class="p">(</span><span class="s2">&quot;expired&quot;</span><span class="p">,</span> <span class="n">timestamp_type</span><span class="p">)</span>
                <span class="o">.</span><span class="n">with_version</span><span class="p">(</span><span class="n">system_keyspace</span><span class="p">::</span><span class="n">generate_schema_version</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span>
                <span class="o">.</span><span class="n">build</span><span class="p">();</span>
</pre></div>
</div>
<p>The entire set of stream IDs (for all token ranges) was stored as a single collection. With large clusters the collection could grow quite big: for example, with 100 nodes 64 shards each and 256 vnodes per node, a new generation would contain 1,6M stream IDs, resulting in a ~32MB collection. For reasons described in issue #7993 this would disqualify the previous schema.</p>
<p>However, that was the schema used in the Scylla 4.3 release. For clusters that used CDC with this schema we need to ensure that stream descriptions residing in the old table appear in the new table as well (if necessary, i.e. if these streams may still contain some data).</p>
<p>To do that, we perform a rewrite procedure. Each node does the following on restart:</p>
<ol class="simple">
<li><p>Check if the <code class="docutils literal notranslate"><span class="pre">system_distributed.cdc_streams_descriptions</span></code> table exists. If it doesn’t, there’s nothing to rewrite, so stop.</p></li>
<li><p>Check if the <code class="docutils literal notranslate"><span class="pre">system.cdc_local</span></code> table contains a row with <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">=</span> <span class="pre">&quot;rewritten&quot;</span></code>. If it does then rewrite was already performed, so stop.</p></li>
<li><p>Check if there is a table with CDC enabled. If not, add a row with <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">=</span> <span class="pre">&quot;rewritten&quot;</span></code> to <code class="docutils literal notranslate"><span class="pre">system.cdc_local</span></code> and stop; no rewriting is necessary (and won’t be) since old generations - even if they exists - are not needed.</p></li>
<li><p>Retrieve all generation timestamps from the old streams description table by performing a full range scan: <code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">time</span> <span class="pre">from</span> <span class="pre">system_distributed.cdc_streams_descriptions</span></code>. This may be a long/expensive operation, hence it’s performed in a background task (the procedure is moved to background in this step).</p></li>
<li><p>Filter out timestamps that are “too old”. A generation timestamp is “too old” if there is a greater timestamp <code class="docutils literal notranslate"><span class="pre">T</span></code> such that for every table with CDC enabled, <code class="docutils literal notranslate"><span class="pre">now</span> <span class="pre">-</span> <span class="pre">ttl</span> <span class="pre">&gt;</span> <span class="pre">T</span></code>, where <code class="docutils literal notranslate"><span class="pre">now</span></code> is the current time and <code class="docutils literal notranslate"><span class="pre">ttl</span></code> is the table’s TTL setting. This means that the table cannot contain data that belongs to the “too old” generation. Thus, if each table passes this check for a given generation, that generation doesn’t need to be rewritten.</p></li>
<li><p>For each timestamp that’s left:
6.1 if it’s already present in the new table, skip it (we check this by querying <code class="docutils literal notranslate"><span class="pre">cdc_generation_timestamps</span></code>
6.2 fetch the generation (by querying <code class="docutils literal notranslate"><span class="pre">cdc_generation_descriptions</span></code>)
6.3 insert the generation’s streams into the new table</p></li>
<li><p>Insert a row with <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">=</span> <span class="pre">&quot;rewritten&quot;</span></code> into <code class="docutils literal notranslate"><span class="pre">system.cdc_local</span></code>.</p></li>
</ol>
<p>Note that every node will perform this procedure on upgrade, but there’s a high chance that only one of them actually proceeds all the way to step 6.2 if upgrade is performed correctly, i.e. in a rolling fashion (nodes are restarted one-by-one).</p>
<p>In order to prevent new nodes to do the rewriting (we only want upgrading nodes to do it), we insert the <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">=</span> <span class="pre">&quot;rewritten&quot;</span></code> row on bootstrap as well, before we start this procedure (so the node won’t pass the second check).</p>
<section id="todo-expired-generations">
<h3>TODO: expired generations<a class="headerlink" href="#todo-expired-generations" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">expired</span></code> column in <code class="docutils literal notranslate"><span class="pre">cdc_generation_timestamps</span></code> and <code class="docutils literal notranslate"><span class="pre">cdc_generation_descriptions</span></code> means that this generation was superseded by some new generation and will soon be removed (its table entry will be gone). This functionality is yet to be implemented.</p>
</section>
</section>
</section>

        </div>

        <div id="sidebar" class="large-3 large-pull-6 columns"><div class="side-nav">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Scylla Developer Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../alternator/alternator.html">Alternator: DynamoDB API in Scylla</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Design Notes</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="IDL.html">IDL definition</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">CDC</a></li>
<li class="toctree-l2"><a class="reference internal" href="compaction_controller.html">The Compaction Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="cql-extensions.html">Scylla CQL extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="cql-extensions-internal.html">Scylla CQL extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="cql3-type-mapping.html">CQL3 Type Mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="hinted_handoff_design.html">Hinted Handoff Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="isolation.html">Performance Isolation in Scylla</a></li>
<li class="toctree-l2"><a class="reference internal" href="lua-type-mapping.html">CQL to Lua type mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="metrics.html">Scylla Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="migrating-from-users-to-roles.html">Migrating from users to roles</a></li>
<li class="toctree-l2"><a class="reference internal" href="paged-queries.html">Paged queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocol-extensions.html">Protocol extensions to the Cassandra Native Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="protocols.html">Ports and protocols in Scylla</a></li>
<li class="toctree-l2"><a class="reference internal" href="redis.html">Redis API in Scylla</a></li>
<li class="toctree-l2"><a class="reference internal" href="repair_based_node_ops.html">Repair based node operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="row_cache.html">Row Cache</a></li>
<li class="toctree-l2"><a class="reference internal" href="row_level_repair.html">Row level repair</a></li>
<li class="toctree-l2"><a class="reference internal" href="secondary_index.html">Secondary indexes in Scylla</a></li>
<li class="toctree-l2"><a class="reference internal" href="sstable-scylla-format.html">File format of the Scylla.db sstable component</a></li>
<li class="toctree-l2"><a class="reference internal" href="sstables-directory-structure.html">sstables directory structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="system_keyspace.html">System keyspace layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="system_schema_keyspace.html">System schema keyspace layout</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../guides/index.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">Contribute</a></li>
</ul>

</div>
        </div>

        <div class="large-3 columns">
            
                <div class="versions-dropdown single-version">
    <button class="button">
    
        master
    
	 <i class="fa fa-caret-down" aria-hidden="true"></i>
    </button>
    <ul class="content">
            <li><a href="cdc.html">master</a></li>
    </ul>
</div>
            
        </div>

    </div>
</section>

<!-- newsleter modal -->

<div id="newsletter_signup" class="reveal-modal tiny radius dark_modal" data-reveal aria-labelledby="modalTitle" aria-hidden="true" role="dialog">
    <a class="close-reveal-modal" aria-label="Close">×</a>
    <h2 id="modalTitle">Sign up for the Scylla newsletter</h2>
    <div id="mc_embed_signup">
        <form action="//cloudius-systems.us10.list-manage.com/subscribe/post?u=df8bb543c68230d5f7b4dcf78&amp;id=9a4589f144" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
            <div id="mc_embed_signup_scroll">

                <div class="mc-field-group">
                    <div class="row collapse">
                        <div class="small-3 columns"><label for="mce-EMAIL">Email</label></div>
                        <div class="small-9 columns"><input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL"></div>
                    </div>
                </div>
                <div class="mc-field-group">
                    <div class="row collapse">
                        <div class="small-3 columns"><label for="mce-FNAME">First Name </label></div>
                        <div class="small-9 columns"><input type="text" value="" name="FNAME" class="" id="mce-FNAME"></div>
                    </div>
                </div>
                <div class="mc-field-group">
                    <div class="row collapse">
                        <div class="small-3 columns"><label for="mce-LNAME">Last Name </label></div>
                        <div class="small-9 columns"><input type="text" value="" name="LNAME" class="" id="mce-LNAME"></div>
                    </div>
                </div>
                <div id="mce-responses" class="clear">
                    <div class="response" id="mce-error-response" style="display:none"></div>
                    <div class="response" id="mce-success-response" style="display:none"></div>
                </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
                <div style="position: absolute; left: -5000px;"><input type="text" name="b_df8bb543c68230d5f7b4dcf78_9a4589f144" tabindex="-1" value=""></div>
                <div class="clear"><input type="submit" class="button" value="Sign up" name="subscribe" id="mc-embedded-subscribe"></div>
            </div>
        </form>
    </div>
</div>

<!-- end newsleter modal -->



<!-- footer.html -->
<footer id="footer">
    <div class="footer-top">
        <a class="logo" href="https://www.scylladb.com"><img src="../_static/img/logo-scylla-horizontal-RGB.svg" alt=""></a>
        <div class="footer-links">
            <a class="link" href="https://docs.scylladb.com">Docs</a>
            <a class="link" href="https://www.scylladb.com/company/contact-us/">Contact Us</a>
            <a class="link" href="https://www.scylladb.com/company/">About Us</a>
            <a class="link button" href="https://github.com/scylladb/scylla/issues/new?title=Issue in page CDC&&body=I%20would%20like%20to%20report%20an%20issue%20in%20page%20https://scylla.docs.scylladb.com/master/design-notes/cdc%0A%0A%23%23%23%20Problem%0A%0A%23%23%23%20%20Suggest%20a%20fix" target="_blank">
                Report an issue on this page</a>
        </div>
        <div class="footer-actions">
            <a class="link-icon" href="https://github.com/ScyllaDB" target="_blank">
                <span class="icon-github2"></span></a>
            <a class="link-icon" href="https://twitter.com/ScyllaDB" target="_blank">
                <span class="icon-twitter"></span></a>
            <a class="link-icon" href="https://www.linkedin.com/company/scylladb"  target="_blank">
                <span class="icon-linkedin2"></span></a>
            <a class="link-icon" href="https://www.facebook.com/scylladb/" target="_blank">
                <span class="icon-facebook"></span></a>
        </div>
    </div>

    <div class="footer-bottom">
        <div class="footer-info">
            <div class="footer-copyright">
                &#169; 2021, ScyllaDB. All rights reserved.
            </div>
            <div class="footer-last-updated">
                Last updated on 11 May 2021.
            </div>
            <div class="footer-version">
                Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
                &amp; <a href="https://pypi.org/project/sphinx-scylladb-theme">ScyllaDB Theme 0.1.23</a>
            </div>
        </div>
        <div class="footer-links">
        </div>
    </div>
</footer>
<!-- end footer.html -->

<!-- bodyscripts.html -->
<!-- at the end of the BODY --> 
<script src="../_static/js/vendor/jquery.js"></script>
<script src="../_static/js/vendor/jquery.cookie.min.js"></script>
<script src="../_static/expertrec.js"></script>
<script src="../_static/js/foundation/foundation.js"></script>
<script src="../_static/js/foundation/foundation.topbar.js"></script>
<script src="../_static/app.js"></script>
<script>
    $(document).foundation();
</script>
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-T8P2JP"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

  <!-- end bodyscripts.html -->
</body>
</html>